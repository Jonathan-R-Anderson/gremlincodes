<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gremlin Threads</title>
    <script src="https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/webtorrent/webtorrent.min.js"></script>

    <style>
        .thread-container {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid #ccc;
            background-color: #f9f9f9;
        }

        .reply-container {
            margin-left: 20px;
            padding: 10px;
            border-left: 3px solid #ccc;
            background-color: #f0f0f0;
        }

        /* Initial small image size */
        img.thumbnail {
            display: block;
            width: 50px;
            height: 50px;
            cursor: pointer; /* Make it look clickable */
            transition: transform 0.2s ease;
        }

        /* Enlarged image */
        img.enlarged {
            width: auto;
            height: auto;
            max-width: 100%;
            max-height: 100%;
        }

        #overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 0;
            background-color: rgba(0, 0, 0, 0.9);
            overflow-y: hidden;
            transition: 0.5s;
            z-index: 9999;
        }

        #overlayContent {
            position: relative;
            top: 25%;
            width: 80%;
            margin: auto;
            color: white;
        }

        .navbar {
            padding: 10px;
            background-color: #333;
            color: white;
        }

        .search-box {
            padding: 10px;
            margin: 10px 0;
        }

        #showOverlayBtn, #closeOverlayBtn {
            display: block;
            margin: 10px auto;
            padding: 10px 20px;
        }

        .placeholder-content {
            width: 100%;
            height: 200px;
            background-color: #eaeaea;
            display: block;
            text-align: center;
            line-height: 200px;
            font-size: 14px;
            color: #ccc;
        }
    </style>
</head>
<body>
    <div class="navbar">
        ManiwaniBoard
    </div>

    <div class="search-box">
        <input type="text" id="searchBar" placeholder="Enter tags..." onkeyup="filterThreads()" />
    </div>

    <div class="container" id="infiniteScrollContent">
        <!-- Threads will be dynamically loaded here -->
    </div>

    <button id="showOverlayBtn" onclick="showOverlay()">Create Post</button>
    <button id="closeOverlayBtn" onclick="closeOverlay()">Cancel</button>

    <div id="overlay">
        <div id="overlayContent">
            <h2 id="overlayTitle">Create a New Post</h2>
            <input type="text" id="newPostTitle" placeholder="Title" style="width: 100%; padding: 10px;" />
            <textarea id="newPostContent" placeholder="Content" style="width: 100%; padding: 10px; height: 100px;"></textarea>
            <input type="text" id="newPostTags" placeholder="Tags (comma-separated)" style="width: 100%; padding: 10px;" />
            <input type="file" id="imageUpload" accept="image/*" style="width: 100%; padding: 10px;" />
            <button id="submitPostBtn" onclick="submitPost()">Submit Post</button>
        </div>
    </div>

    <script>
        let gremlinThreadContract;
        let currentScrollPage = 1;
        let loadedThreads = 0;
        let replyingToThreadId = null; // To track which thread we are replying to
        const postsToLoad = 5;

        // Initialize WebTorrent client
        const client = new WebTorrent();

        // Store a reference to the added torrents
        const addedTorrents = new Set();

        async function initializeContracts() {
            if (typeof window.ethereum !== 'undefined') {
                const web3 = new Web3(window.ethereum);

                try {
                    await window.ethereum.request({ method: 'eth_requestAccounts' });

                    gremlinThreadContract = new web3.eth.Contract(
                        {{ gremlinThreadABI | safe }},
                        '{{ gremlinThreadAddress }}'
                    );
                    await loadMorePosts();
                } catch (error) {
                    alert('Could not access MetaMask. Please ensure MetaMask is installed and you have authorized access.');
                    console.log(error);
                }
            } else {
                alert('MetaMask is not installed. Please install MetaMask to use this application.');
            }
        }

        async function getAllThreads(start, limit) {
            console.log(`getAllThreads called with start=${start}, limit=${limit}`);
            try {
                const threadCount = await gremlinThreadContract.methods.getThreadCount().call();
                console.log(`Total threads available: ${threadCount}`);
                const totalThreads = Number(threadCount);

                let threads = [];

                for (let i = start + 1; i <= Math.min(start + limit, totalThreads); i++) {
                    try {
                        console.log(`Fetching thread ${i}...`);
                        const thread = await gremlinThreadContract.methods.getThreadInfo(i).call();
                        console.log(`Thread ${i} fetched:`, thread);

                        thread.id = i;

                        thread.timestamp = thread.timestamp ? new Date(thread.timestamp * 1000).toLocaleString() : "No timestamp available";
                        thread.lastReplyTimestamp = thread.lastReplyTimestamp ? new Date(thread.lastReplyTimestamp * 1000).toLocaleString() : "No last reply timestamp available";

                        threads.push(thread);
                    } catch (innerError) {
                        console.log(`Error fetching thread ${i}:`, innerError);
                    }
                }

                threads.sort((a, b) => b.id - a.id);

                for (let thread of threads) {
                    await displayThread(thread);
                    console.log(`Thread ${thread.id} displayed.`);
                    loadedThreads++;
                }

            } catch (error) {
                console.log('Error in getAllThreads:', error);
            }
        }

        async function submitPost() {
            const title = document.getElementById('newPostTitle').value;
            const content = document.getElementById('newPostContent').value;
            const tags = document.getElementById('newPostTags').value.split(',').map(tag => tag.trim());
            const imageFile = document.getElementById('imageUpload').files[0];

            try {
                const magnetUrl = await uploadToServer(imageFile);
                const attachments = [magnetUrl];
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                const account = accounts[0];

                let tx;
                if (replyingToThreadId) {
                    console.log(`Submitting reply to thread ID: ${replyingToThreadId}`);
                    tx = await gremlinThreadContract.methods.replyToThread(replyingToThreadId, content, attachments).send({ from: account });
                } else {
                    console.log(`Submitting post with title: ${title}, content: ${content}, tags: ${tags}, attachments: ${attachments}`);
                    const gasEstimate = await gremlinThreadContract.methods.createThread(title, tags, attachments).estimateGas({ from: account });
                    tx = await gremlinThreadContract.methods.createThread(title, tags, attachments).send({ from: account, gas: gasEstimate});
                }

                closeOverlay();
                await refreshThreads();
            } catch (error) {
                console.log('Error in submitPost:', error);
            }
        }

        async function uploadToServer(file) {
            return new Promise((resolve, reject) => {
                client.seed(file, (torrent) => {
                    console.log('Seeding started:', torrent.magnetURI);
                    resolve(torrent.magnetURI);
                });
            });
        }

        async function refreshThreads() {
            document.getElementById('infiniteScrollContent').innerHTML = '';
            loadedThreads = 0;
            currentScrollPage = 1;
            await loadMorePosts();
        }

        async function loadMorePosts() {
            await getAllThreads(loadedThreads, postsToLoad);
            currentScrollPage++;
        }

        async function displayThread(thread) {
            const threadContainer = document.createElement('div');
            threadContainer.className = 'thread-container';
            threadContainer.id = `thread-${thread.id}`;

            const subject = document.createElement('h3');
            subject.innerText = `Subject: ${thread.subject}`;
            threadContainer.appendChild(subject);

            const tags = Array.isArray(thread.tags) ? thread.tags.join(', ') : thread.tags;
            const tagsElement = document.createElement('p');
            tagsElement.innerText = `Tags: ${tags}`;
            threadContainer.appendChild(tagsElement);

            const ethAddressElement = document.createElement('p');
            ethAddressElement.innerText = `Ethereum Address: ${thread.ethAddress}`;
            threadContainer.appendChild(ethAddressElement);

            // Add a "Reply" link to open the overlay for replying
            const replyLink = document.createElement('a');
            replyLink.href = '#';
            replyLink.innerText = 'Reply';
            replyLink.addEventListener('click', () => openReplyOverlay(thread.id));
            threadContainer.appendChild(replyLink);

            const contentPlaceholder = document.createElement('div');
            contentPlaceholder.className = 'placeholder-content';
            contentPlaceholder.innerText = 'Loading content...';
            threadContainer.appendChild(contentPlaceholder);

            document.getElementById('infiniteScrollContent').appendChild(threadContainer);

            const attachments = thread.attachments || [];
            for (let attachment of attachments) {
                await downloadAndDisplayContent(thread.id, attachment);
            }

            // Fetch and display the last 3 replies
            const replies = await getThreadReplies(thread.id);
            replies.slice(-3).forEach(reply => {
                displayReply(reply, threadContainer);
            });
        }

        async function getThreadReplies(threadId) {
            // Fetch all replies from smart contract
            const replyCount = await gremlinThreadContract.methods.getReplyCount(threadId).call();
            const replies = [];
            for (let i = 0; i < replyCount; i++) {
                const reply = await gremlinThreadContract.methods.getReply(threadId, i).call();
                replies.push(reply);
            }
            return replies;
        }

        async function displayReply(reply, threadContainer) {
            const replyContainer = document.createElement('div');
            replyContainer.className = 'reply-container';

            const contentElement = document.createElement('p');
            contentElement.innerText = reply.content;
            replyContainer.appendChild(contentElement);

            // Append reply to the thread container
            threadContainer.appendChild(replyContainer);
        }

        async function downloadAndDisplayContent(threadId, magnetUrl) {
            // Check if the torrent has already been added
            if (addedTorrents.has(magnetUrl)) {
                console.log(`Torrent already added for thread ${threadId} with magnet URL: ${magnetUrl}`);
                return; // Exit the function since it's already added
            }

            // Add the magnet URL to the Set to prevent duplicates
            addedTorrents.add(magnetUrl);

            try {
                // Add the torrent using WebTorrent
                client.add(magnetUrl, (torrent) => {
                    console.log(`Torrent added for thread ${threadId} with magnet URL: ${magnetUrl}`);

                    // Find the first image file in the torrent
                    const file = torrent.files.find(file =>
                        file.name.endsWith('.png') || file.name.endsWith('.jpg') || file.name.endsWith('.jpeg')
                    );

                    if (file) {
                        // Generate a Blob URL and create an image element
                        file.getBlobURL((err, url) => {
                            if (err) {
                                console.error(`Error generating Blob URL for thread ${threadId}:`, err);
                                removePost(threadId); // Remove the post if the image fails to load
                                return;
                            }

                            const img = document.createElement('img');
                            img.src = url;
                            img.alt = file.name;
                            img.classList.add('thumbnail'); // Add the thumbnail class to style as 50x50 initially

                            // Insert the image into the thread's container
                            const threadContainer = document.querySelector(`#thread-${threadId} .placeholder-content`);
                            if (threadContainer) {
                                threadContainer.innerHTML = ''; // Clear any previous content
                                threadContainer.appendChild(img);
                                console.log(`Image displayed for thread ${threadId}`);
                            }

                            // Toggle between enlarged and thumbnail on click
                            img.addEventListener('click', function () {
                                if (img.classList.contains('enlarged')) {
                                    img.classList.remove('enlarged');
                                    img.classList.add('thumbnail');
                                } else {
                                    img.classList.remove('thumbnail');
                                    img.classList.add('enlarged');
                                }
                            });

                            // Handle image load failure (e.g., if the image is corrupted or cannot be loaded)
                            img.onerror = function() {
                                console.error(`Failed to load image for thread ${threadId}. Removing post.`);
                                removePost(threadId); // Remove the post if the image fails to load
                            };
                        });
                    } else {
                        console.log(`No image file found in torrent for thread ${threadId}`);
                        removePost(threadId); // Remove the post if no image file is found
                    }
                });
            } catch (error) {
                console.error(`Error adding torrent for thread ${threadId}:`, error);
                removePost(threadId); // Remove the post in case of an error
            }
        }

        function removePost(threadId) {
            const threadContainer = document.getElementById(`thread-${threadId}`);
            if (threadContainer) {
                threadContainer.remove(); // Remove the entire post from the DOM
                console.log(`Post removed for thread ${threadId}`);
            }
        }

        function showOverlay() {
            replyingToThreadId = null;
            document.getElementById('overlayTitle').innerText = 'Create a New Post';
            document.getElementById('overlay').style.height = "100%";
            document.getElementById('closeOverlayBtn').style.display = 'block';
        }

        function openReplyOverlay(threadId) {
            replyingToThreadId = threadId;
            document.getElementById('overlayTitle').innerText = 'Reply to Thread';
            document.getElementById('overlay').style.height = "100%";
        }

        function closeOverlay() {
            replyingToThreadId = null;
            document.getElementById('overlayTitle').innerText = 'Create a New Post';
            document.getElementById('overlay').style.height = "0%";
            document.getElementById('closeOverlayBtn').style.display = 'none';
        }

        window.onscroll = function() {
            if (window.innerHeight + window.scrollY >= document.body.offsetHeight) {
                loadMorePosts();
            }
        };

        window.onload = function() {
            initializeContracts();
        };
    </script>
</body>
</html>
